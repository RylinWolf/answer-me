# 介绍

AI 答题平台，用户可以基于 AI 快速制作并发布答题应用，支持检索、分享、在线答题，
并基于 AI 得到回答总结。管理员可以审核应用、集中管理内容。

## 开发阶段

- 开发答题应用平台。用户可以上传题目和自定义打分规则。
- 使用 AI 赋能，开发 AI 智能答题应用平台。用户设定主题，通过 AI 生成题目、分析用户答案。

# 核心业务开发

1. 用户注册 - 登录
2. 用户创建应用 => 创建题目（题目项目得分）=> 创建评分规则（方式 + 结果）
3. 管理员审核应用
4. 用户查看、检索应用列表，进入详情页，在线答题并提交
5. 评分计算，用户查看评分结果

## 额外开发

- 应用模块
    - 审核发布、下架应用
- 评分模块
    - 根据回答计算评分结果
        - 策略模式，测评类、打分类
- 回答模块
    - 提交回答，之后可以调用评分模块并更新回答表

# 平台智能化

- 接入 AI 模块
- 通过 AI 生成题目
    - 提示词约束 AI 回答
    - 将 AI 回答内容转换为对象
- 通过 AI 进行评分

# 性能优化

- RxJava 响应式编程
- Ai 生成题目优化
- Ai 评分优化
- 分库分表

## RxJava

响应式编程的库，核心为 reactivex。

响应式编程，是一种编程范式。专注于异步数据流和变化传播。

- 变化传播：数据源发生变化时，响应式编程模型会自动将这种变化传播到依赖数据源的地方。

RxJava 是一个基于事件驱动的、利用可观测序列来实现异步编程的类库。

### 事件驱动

事件可以是任何事情，如用户点击、网络请求结果、文件读写等。
RxJava 中，事件也可以是数据流中的数据项，称为事件流。

### 可观测序列

指一系列按照时间顺序发出的数据项可以被观察和处理。

### 观察者模式

RxJava 是基于观察者模式实现的。分为观察者、被观察者两个角色。
被观察者会实时传输数据流，观察者可以观测到这些数据流。

RxJava 中，观察者是 Observer，被观察者是 Observable 和 Flowable。

- Observable 适合处理相对较小的、可控的、不会迅速产生大量数据的场景。
- Flowable 针对背压（反向压力）问题设计的可观测类型。

### 事件

- onNext 被观察者每发送一次数据
- onError 发送数据过程中产生意料之外的错误
- onComplete 没有发生错误，最后一次调用 onNext 后发送此事件

### SSE

Server-Send Events，基于 Http 实现。

- 单向通信
- 文本格式 text/event-stream
- 保持连接诶
- 自动重连：如果连接中断，浏览器自动重新尝试连接

### 实现

- 前端向后端发送 Http 请求
- 后端创建 SSE 连接对象，为推送做准备
- 后端流式调用 AI，获取数据流并订阅
- 以 SSE 方式响应前端
- 异步：基于 RxJava 实时获取 AI 数据，持续将数据拼接为字符串，每拼接为一道题目时，通过 SSE 推送给前端

## 分库分表

- user_answer 用户答题记录表
  一个用户可以对多个应用多次答题，理论上可能遇到瓶颈。

数据库里的数据过多，可能查询过慢，因为底层的 B+树过高，IO 性能低。

**如何区分？**

- 分库：把一个数据库实例里的数据拆分为多个数据库实例，部署在不同的服务器。（横向、垂直）
- 分表：把一张表里的数据拆分成多张表（横向、垂直）

**一般来说，**

- 分表：解决单张表数据量大而导致的查询慢问题，大概三、四千万行数据就要拆分。
  如果字段大可能上千万就要拆分了。
- 分库：解决服务器资源受单机限制，顶不住高并发访问的问题